{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "\n",
    "\n",
    "\"\"\"\n",
    "functions:\n",
    "cis_plot\n",
    "    format_pval_annotation\n",
    "    pval_annotation\n",
    "        get_pval_symbol\n",
    "\n",
    "add_sig_col (wrap_ttest_return_all)\n",
    "\"\"\"\n",
    "\n",
    "def rename_columns(df):\n",
    "    # for 3 copies only\n",
    "    cols = []\n",
    "    one_before = ''\n",
    "    two_before = ''\n",
    "    for column in df.columns:\n",
    "\n",
    "        if column == one_before: \n",
    "            column = column+\"_\"+str(2)\n",
    "            cols.append(column)\n",
    "            two_before = one_before\n",
    "            one_before = column\n",
    "            continue\n",
    "\n",
    "        elif column == two_before:\n",
    "            column = column+\"_\"+str(3)\n",
    "            cols.append(column)\n",
    "            two_before = one_before\n",
    "            one_before = column\n",
    "            continue\n",
    "        else:\n",
    "            cols.append(column)\n",
    "            two_before = one_before\n",
    "            one_before = column\n",
    "            continue\n",
    "            \n",
    "    df.columns = cols\n",
    "    return df\n",
    "\n",
    "def format_pval_annotation(pval_symbol, x1, x2, line_start = .05, line_height=.05):\n",
    "    # for manual adjustment to pval annotations\n",
    "    \n",
    "    y, h = line_start, line_height\n",
    "    plt.plot([x1, x1, x2, x2], #draw horizontal line\n",
    "             [y, y+h, y+h, y], #vertical line\n",
    "             lw=1.5, color= '.3')\n",
    "    plt.text((x1+x2)*.5, # half between x coord\n",
    "             y+h, pval_symbol, horizontalalignment='center', verticalalignment='bottom', color = \"black\")\n",
    "\n",
    "# used in pval_annotation\n",
    "def get_pval_symbol(pval_df):\n",
    "    if pval_df.iloc[0:,2].bool() == True:\n",
    "        pval_symbol = '*'\n",
    "    else:\n",
    "        pval_symbol = 'ns'\n",
    "    return pval_symbol\n",
    "\n",
    "def pval_annotation(pval_df, plotted_df):\n",
    "    # pval symbol\n",
    "    num_pvals = len(pval_df)\n",
    "    omics_col = plotted_df.columns[0]\n",
    "    \n",
    "\n",
    "    # annotation for Mutated and Wiltype\n",
    "    if num_pvals == 1:\n",
    "        mut_pval = pval_df.loc[pval_df.index == \"Mutated/Wildtype\"]\n",
    "        mut_pval_symbol = get_pval_symbol(pval_df)\n",
    "        \n",
    "        x1, x2 = 0, 1   # columns (first column: 0, see plt.xticks())\n",
    "        y, h = plotted_df[omics_col].max() + .05, .05     \n",
    "        plt.plot([x1, x1, x2, x2], #draw horizontal line\n",
    "                 [y, y+h, y+h, y], #vertical line\n",
    "                 lw=1.5, color= '.3')\n",
    "        plt.text((x1+x2)*.5, # half between x coord\n",
    "                 y+h, mut_pval_symbol, horizontalalignment='center', verticalalignment='bottom', color = \"black\")\n",
    "    \n",
    "    # annotation for Missense, Truncation and Wildtype\n",
    "    elif num_pvals == 2:\n",
    "        # Missense\n",
    "        miss_pval = pval_df.loc[pval_df.index == \"Missense/Wildtype\"]\n",
    "        miss_pval_symbol = get_pval_symbol(miss_pval)\n",
    "    \n",
    "        x1, x2 = 0, 1   # columns (first column: 0, see plt.xticks())\n",
    "        y, h = plotted_df[omics_col].max() + .05, .05     \n",
    "        plt.plot([x1, x1, x2, x2], #draw horizontal line\n",
    "                 [y, y+h, y+h, y], #vertical line\n",
    "                 lw=1.5, color= '.3')\n",
    "        plt.text((x1+x2)*.5, # half between x coord\n",
    "                 y+h, miss_pval_symbol, horizontalalignment='center', verticalalignment='bottom', color = \"black\")\n",
    "        \n",
    "        # Truncation \n",
    "        trunc_pval = pval_df.loc[pval_df.index == \"Truncation/Wildtype\"]\n",
    "        trunc_pval_symbol = get_pval_symbol(trunc_pval)\n",
    "        \n",
    "        x3, x4 = 0, 2   # columns (first column: 0, see plt.xticks())\n",
    "        y2, h2 = plotted_df[omics_col].max() + .15, .05     \n",
    "        plt.plot([x3, x3, x4, x4], #draw horizontal line\n",
    "                 [y2, y2+h2, y2+h2, y2], #vertical line\n",
    "                 lw=1.5, color= '.3')\n",
    "        plt.text((x3+x4)*.5, # half between x coord\n",
    "                 y2+h2, trunc_pval_symbol, horizontalalignment='center', verticalalignment='bottom', color = \"black\")\n",
    "\n",
    "        \n",
    "        \n",
    "        \n",
    "        \n",
    "# Create boxplot and stripplot with pval annotation\n",
    "def cis_plot(df, gene, omics_name, pval_df, mutation_type=\"Mutated\"):\n",
    "    omics_col = gene+\"_\"+omics_name\n",
    "    \n",
    "    # get right order for boxplots\n",
    "    mutations = df['binary_mutations'].unique()\n",
    "    if len(mutations) == 2:\n",
    "        order_mutations = ['Wildtype', 'Mutated']\n",
    "        num_pvals = 1\n",
    "    else:\n",
    "        order_mutations = ['Wildtype', 'Missense', 'Truncation']\n",
    "        num_pvals = 2\n",
    "    '''    \n",
    "    if num_pvals == 1:\n",
    "        pval = get_pval(pval_df)\n",
    "        str_pval = \"P-Value = \"+str(pval)+\"\\n\"\n",
    "    else:\n",
    "        str_pval = ''\n",
    "    '''    \n",
    "    # Boxplot and Stripplot\n",
    "    plt.rcParams['figure.figsize']=(8,5)\n",
    "    sns.set(font_scale = 1.3)\n",
    "    cis_boxplot = sns.boxplot(data = df, x = 'binary_mutations',\n",
    "                              y = omics_col, order = order_mutations, showfliers = False)  \n",
    "    cis_boxplot.set_title(\n",
    "        gene + \" Effect on \" + gene +\" \"+omics_name.capitalize()+\" in Kidney Tumors\\n\")\n",
    "    cis_boxplot = sns.stripplot(data= df, x = 'binary_mutations',\n",
    "                                y = omics_col,jitter = True, color = \".3\", order = order_mutations)\n",
    "    cis_boxplot.set(xlabel = \"\\n\"+gene + \" Mutation Status in Tumors\", ylabel = omics_name.capitalize())\n",
    "    cis_boxplot.set_xticklabels(cis_boxplot.get_xticklabels())\n",
    "    \n",
    "    pval_annotation(pval_df, df)\n",
    "    \n",
    "    plt.show()\n",
    "    plt.clf()\n",
    "    plt.close()\n",
    "    \n",
    "    \n",
    "# get pval from dataframe -- used in cis_plot\n",
    "def get_pval(results_df):\n",
    "    if isinstance(results_df, pd.DataFrame):\n",
    "        pval_series = results_df['P_Value']\n",
    "        num_pval = float(pval_series[0])\n",
    "        return num_pval\n",
    "    else:\n",
    "        return \"Not Significant\" # > 0.05\n",
    "\n",
    "# used in wrap_ttest_return_all\n",
    "def add_significance_col(results_df, num_comparisons):\n",
    "    \"bonferroni multiple hypothesis\"\"\"\n",
    "    alpha = .05\n",
    "    bonferroni_cutoff = alpha / num_comparisons\n",
    "    \n",
    "    pval = results_df['P_Value']\n",
    "    if float(pval[0]) <= bonferroni_cutoff:\n",
    "        results_df['Significant'] = True\n",
    "    else: \n",
    "        results_df['Significant'] = False\n",
    "    return results_df\n",
    "\n",
    "def wrap_ttest_return_all(df, label_column, comparison_columns, total_tests=1, alpha=.05):\n",
    "    try:\n",
    "        #Verify precondition that label column exists and has exactly 2 unique values\n",
    "        label_values = df[label_column].unique()\n",
    "        if len(label_values) != 2:\n",
    "            print(\"Incorrectly Formatted Dataframe! Label column must have exactly 2 unique values.\")\n",
    "            return None\n",
    "        \n",
    "        #Partition dataframe into two sets, one for each of the two unique values from the label column\n",
    "        partition1 = df.loc[df[label_column] == label_values[0]]\n",
    "        partition2 = df.loc[df[label_column] == label_values[1]]\n",
    "        \n",
    "        #Determine the number of real valued columns on which we will do t-tests\n",
    "        number_of_comparisons = total_tests # ? phospho sites or num freq mut genes doing cis comp\n",
    "        \n",
    "        #Use a bonferroni correction to adjust for multiple testing by altering the p-value needed for acceptance\n",
    "        bonferroni_cutoff = alpha/number_of_comparisons\n",
    "        \n",
    "        #Store all comparisons with their p-values in a dictionary\n",
    "        all_comparisons = {}\n",
    "        \n",
    "        #Loop through each comparison column, perform the t-test, and determine whether it meets the significance cutoff'''\n",
    "        for column in comparison_columns:\n",
    "            stat, pval = scipy.stats.ttest_ind(partition1[column].dropna(axis=0), partition2[column].dropna(axis=0))\n",
    "            all_comparisons[column] = pval\n",
    "    \n",
    "        #Sort dictionary to list smallest p-values first\n",
    "        sorted_comparisons = sorted(all_comparisons.items(), key=lambda kv: kv[1])\n",
    "        #Format as a dataframe and return to caller\n",
    "        all_comparisons_df = pd.DataFrame.from_dict(sorted_comparisons)\n",
    "        all_comparisons_df.columns = ['Comparison', 'P_Value']\n",
    "        \n",
    "                                               \n",
    "        all_comparisons_sig_col = add_significance_col(all_comparisons_df, number_of_comparisons)\n",
    "        return all_comparisons_sig_col\n",
    "                                \n",
    "    except:\n",
    "        print(\"Incorrectly Formatted Dataframe!\")\n",
    "        return None\n",
    "\n",
    "\n",
    "def format_cis_comparison_data(cancer_object, omics_name, gene):\n",
    "    import numpy as np\n",
    "    # Step 1 - Create dataframe in order to do comparisons with wrap_ttest - drop nan values\n",
    "    omics_and_mutations = cancer_object.join_omics_to_mutations(\n",
    "        mutations_genes = gene, omics_df_name = omics_name, omics_genes = gene).dropna()\n",
    "    #print(omics_and_mutations.head())\n",
    "    # Check if values in omics data (if not found in proteomics, after na dropped dataframe should be empty)\n",
    "    if omics_and_mutations[gene+\"_\"+omics_name].empty:\n",
    "        print('Not possible to do T-test. No data for', gene, 'in', omics_name)\n",
    "        return None\n",
    "    else:\n",
    "        \n",
    "        # Step 2 - Create the binary column needed to do the comparison\n",
    "        omics_and_mutations['binary_mutations'] = np.where(\n",
    "            omics_and_mutations[gene+'_Mutation_Status'] == 'Wildtype_Tumor', 'Wildtype', 'Mutated')\n",
    "\n",
    "        # Step 3 - Format the dataframe correctly for the T-test(just omics and binary columns for tumors)\n",
    "        tumors = omics_and_mutations.loc[omics_and_mutations['Sample_Status'] == 'Tumor'] #drop Normal samples\n",
    "        columns_to_drop = [gene+\"_Mutation\", gene+\"_Location\", gene+\"_Mutation_Status\", \"Sample_Status\"]\n",
    "        omics_binary_mutations = tumors.drop(columns_to_drop, axis = 1)\n",
    "        #check if only one column of omics data (total 2 columns)\n",
    "        if len(omics_binary_mutations.columns) != 2:\n",
    "            print('exeption with columns. check omics data')\n",
    "            return None\n",
    "            \n",
    "        else:\n",
    "            return omics_binary_mutations\n",
    "\n",
    "def get_missense_truncation_comparison(cancer_object, omics_name, gene):\n",
    "    import numpy as np\n",
    "    #get omics data and tumors\n",
    "    omics_and_mutations = cancer_object.join_omics_to_mutations(\n",
    "                mutations_genes = gene, omics_df_name = omics_name, omics_genes = gene)\n",
    "    tumors = omics_and_mutations.loc[omics_and_mutations['Sample_Status'] == 'Tumor'] #drop Normal samples\n",
    "\n",
    "\n",
    "    somatic_mutations = cancer_object.get_somatic_mutation().reset_index()\n",
    "\n",
    "    if cancer_object.get_cancer_type() == 'colon':\n",
    "        missence_truncation_groups = {'frameshift substitution': 'Truncation', \n",
    "            'frameshift deletion': 'Truncation', 'frameshift insertion': 'Truncation', \n",
    "            'stopgain': 'Truncation', 'stoploss': 'Truncation', 'nonsynonymous SNV': 'Missense',\n",
    "            'nonframeshift insertion': 'Missense','nonframeshift deletion': 'Missense', \n",
    "            'nonframeshift substitution': 'Missense'}\n",
    "    else: \n",
    "        missence_truncation_groups = {'In_Frame_Del': 'Missense', 'In_Frame_Ins': 'Missense',\n",
    "            'Missense_Mutation': 'Missense', 'Frame_Shift_Del': 'Truncation','Nonsense_Mutation': 'Truncation', \n",
    "            'Splice_Site': 'Truncation', 'Frame_Shift_Ins': 'Truncation','Nonstop_Mutation':'Truncation'}\n",
    "\n",
    "    mutations_replaced_M_T = somatic_mutations.replace(missence_truncation_groups)\n",
    "    mutations_replaced_M_T = mutations_replaced_M_T.loc[mutations_replaced_M_T['Gene'] == gene]\n",
    "\n",
    "    # group mutation categories\n",
    "    miss = mutations_replaced_M_T.loc[mutations_replaced_M_T['Mutation'] == 'Missense']\n",
    "    trunc = mutations_replaced_M_T.loc[mutations_replaced_M_T['Mutation'] == 'Truncation']\n",
    "\n",
    "    #get lists of unique samples for missence and trucation categories\n",
    "    miss_unique_samples = list(miss['Sample_ID'].unique())\n",
    "    trunc_unique_samples = list(trunc['Sample_ID'].unique())\n",
    "    \n",
    "    #check if there is only one type of mutation for the specific gene\n",
    "    if miss_unique_samples == []:\n",
    "        print('Only truncation type mutations found for', gene+'.', \n",
    "             'Not possible to compare missense with wildtype.')\n",
    "        truncation_omics = tumors.loc[tumors.index.isin(trunc_unique_samples)]\n",
    "        truncation_omics = truncation_omics.assign(binary_mutations = 'Truncation')\n",
    "        columns_to_drop = [gene+\"_Mutation\", gene+\"_Location\", gene+\"_Mutation_Status\", \"Sample_Status\"]\n",
    "        binary_mut_omics = truncation_omics.drop(columns_to_drop, axis = 1)\n",
    "        return binary_mut_omics\n",
    "    elif trunc_unique_samples == []:\n",
    "        print('Only missence type mutations found for', gene+'.', \n",
    "             'Not possible to compare truncation with wildtype.')\n",
    "        missence_omics = tumors.loc[tumors.index.isin(miss_unique_samples)]\n",
    "        missence_omics = missence_omics.assign(binary_mutations = 'Missense')\n",
    "        columns_to_drop = [gene+\"_Mutation\", gene+\"_Location\", gene+\"_Mutation_Status\", \"Sample_Status\"]\n",
    "        binary_mut_omics = missence_omics.drop(columns_to_drop, axis = 1)\n",
    "        return binary_mut_omics\n",
    "\n",
    "    # Step 2 - Create the binary column needed to do the comparison\n",
    "    # Get mutation catagories with omics data\n",
    "    missence_omics = tumors.loc[tumors.index.isin(miss_unique_samples)]\n",
    "    missence_omics = missence_omics.assign(binary_mutations = 'Missense')\n",
    "    truncation_omics = tumors.loc[tumors.index.isin(trunc_unique_samples)]\n",
    "    truncation_omics = truncation_omics.assign(binary_mutations = 'Truncation')\n",
    "    binary_mut_omics = missence_omics.append(truncation_omics)\n",
    "\n",
    "    # Step 3 - Format the dataframe correctly for the T-test(just omics and binary columns for tumors)\n",
    "    columns_to_drop = [gene+\"_Mutation\", gene+\"_Location\", gene+\"_Mutation_Status\", \"Sample_Status\"]\n",
    "    binary_mut_omics = binary_mut_omics.drop(columns_to_drop, axis = 1)\n",
    "\n",
    "    return binary_mut_omics\n",
    "\n",
    "\n",
    "# PHOSPHOPROTEOMICS\n",
    "\n",
    "def format_phospho_cis_comparison(cancer_object, omics_name, gene, specific_phospho):\n",
    "    import numpy as np\n",
    "    # Step 1 - Create dataframe in order to do comparisons with wrap_ttest\n",
    "    omics_and_mut = cancer_object.join_omics_to_mutations(\n",
    "        mutations_genes = gene, omics_df_name = omics_name, omics_genes = gene)\n",
    "\n",
    "    # Step 2 - Create the binary column needed to do the comparison\n",
    "    omics_and_mut['binary_mutations'] = omics_and_mut[gene+'_Mutation_Status'].apply(\n",
    "        lambda x: 'Wildtype' if x == 'Wildtype_Tumor' else 'Mutated')\n",
    "\n",
    "    # Step 3 - Format the dataframe correctly for the T-test(just omics and binary columns for tumors)\n",
    "    tumors = omics_and_mut.loc[omics_and_mut['Sample_Status'] == 'Tumor'] #drop Normal samples\n",
    "    binary_phospho = tumors[[specific_phospho, 'binary_mutations']].dropna(axis = 0)\n",
    "\n",
    "    return binary_phospho\n",
    "\n",
    "\n",
    "def get_missence_truncation_phospho(cancer_object, omics_name, gene, specific_phospho):\n",
    "    import numpy as np\n",
    "    #get omics data and tumors\n",
    "    omics_and_mutations = cancer_object.join_omics_to_mutations(\n",
    "                mutations_genes = gene, omics_df_name = omics_name, omics_genes = gene)\n",
    "    tumors = omics_and_mutations.loc[omics_and_mutations['Sample_Status'] == 'Tumor'] #drop Normal samples\n",
    "\n",
    "    somatic_mutations = cancer_object.get_somatic_mutation().reset_index()\n",
    "\n",
    "    if cancer_object.get_cancer_type() == 'colon':\n",
    "        missence_truncation_groups = {'frameshift substitution': 'Truncation', \n",
    "            'frameshift deletion': 'Truncation', 'frameshift insertion': 'Truncation', \n",
    "            'stopgain': 'Truncation', 'stoploss': 'Truncation', 'nonsynonymous SNV': 'Missence',\n",
    "            'nonframeshift insertion': 'Missence','nonframeshift deletion': 'Missence', \n",
    "            'nonframeshift substitution': 'Missence'}\n",
    "    else: \n",
    "        missence_truncation_groups = {'In_Frame_Del': 'Missence', 'In_Frame_Ins': 'Missence',\n",
    "            'Missense_Mutation': 'Missence', 'Frame_Shift_Del': 'Truncation','Nonsense_Mutation': 'Truncation', \n",
    "            'Splice_Site': 'Truncation', 'Frame_Shift_Ins': 'Truncation','Nonstop_Mutation':'Truncation'}\n",
    "\n",
    "    mutations_replaced_M_T = somatic_mutations.replace(missence_truncation_groups)\n",
    "    mutations_replaced_M_T = mutations_replaced_M_T.loc[mutations_replaced_M_T['Gene'] == gene]\n",
    "\n",
    "    # group mutation categories\n",
    "    miss = mutations_replaced_M_T.loc[mutations_replaced_M_T['Mutation'] == 'Missence']\n",
    "    trunc = mutations_replaced_M_T.loc[mutations_replaced_M_T['Mutation'] == 'Truncation']\n",
    "\n",
    "    #get lists of unique samples for missence and trucation categories\n",
    "    miss_unique_samples = list(miss['Sample_ID'].unique())\n",
    "    trunc_unique_samples = list(trunc['Sample_ID'].unique())\n",
    "    \n",
    "    #check if there is only one type of mutation for the specific gene\n",
    "    if miss_unique_samples == []:\n",
    "        print('Only truncation type mutations found for', gene+'.', \n",
    "             'Not possible to compare mutation types.')\n",
    "        truncation_omics = tumors.loc[tumors.index.isin(trunc_unique_samples)]\n",
    "        truncation_omics = truncation_omics.assign(binary_mutations = 'Truncation')\n",
    "        columns_to_drop = [gene+\"_Mutation\", gene+\"_Location\", gene+\"_Mutation_Status\", \"Sample_Status\"]\n",
    "        binary_mut_omics = truncation_omics.drop(columns_to_drop, axis = 1)\n",
    "        return binary_mut_omics\n",
    "    elif trunc_unique_samples == []:\n",
    "        print('Only missence type mutations found for', gene+'.', \n",
    "             'Not possible to compare mutation types.')\n",
    "        missence_omics = tumors.loc[tumors.index.isin(miss_unique_samples)]\n",
    "        missence_omics = missence_omics.assign(binary_mutations = 'Missence')\n",
    "        columns_to_drop = [gene+\"_Mutation\", gene+\"_Location\", gene+\"_Mutation_Status\", \"Sample_Status\"]\n",
    "        binary_mut_omics = missence_omics.drop(columns_to_drop, axis = 1)\n",
    "        return binary_mut_omics\n",
    "\n",
    "    # Step 2 - Create the binary column needed to do the comparison\n",
    "    # Get mutation catagories with omics data\n",
    "    missence_omics = tumors.loc[tumors.index.isin(miss_unique_samples)]\n",
    "    missence_omics = missence_omics.assign(binary_mutations = 'Missence')\n",
    "    truncation_omics = tumors.loc[tumors.index.isin(trunc_unique_samples)]\n",
    "    truncation_omics = truncation_omics.assign(binary_mutations = 'Truncation')\n",
    "    binary_mut_omics = missence_omics.append(truncation_omics)\n",
    "\n",
    "    # Step 3 - Format the dataframe correctly for the T-test(just omics and binary columns for tumors)\n",
    "    columns_to_drop = [gene+\"_Mutation\", gene+\"_Location\", gene+\"_Mutation_Status\", \"Sample_Status\"]\n",
    "    binary_mut_omics = binary_mut_omics.drop(columns_to_drop, axis = 1)\n",
    "    \n",
    "    # select specific col and drop nan rows\n",
    "    binary_phospho = binary_mut_omics[[specific_phospho, 'binary_mutations']].dropna(axis = 0)\n",
    "\n",
    "    return binary_phospho"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
